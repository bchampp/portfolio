{"pageProps":{"postData":{"id":"portfolio","contentHtml":"<p><img src=\"/projects/portfolio/banner.png\" alt=\"Banner\"></p>\n<h1><code>brentchampion.com</code></h1>\n<p>I've been through 3 iterations of my portfolio website. The first two weren't <em>that bad</em>, but I was never happy with them.</p>\n<!-- My first try was a static HTML page; I bootstrapped an html template I liked, filled it up with some content and threw it in an S3 bucket. Attempt #2 was again, a template I bootstrapped, this time using React. I made it during the couple weeks I had off before starting my internship with [Acoutera](/work/acoutera) to practice React. \r\n\r\nThey lacked authenticity. I don't want my portfolio website to be an electronic copy of my resume, or a 'fill in the blank' portfolio template. I want it to be a place to experiment, talk about things I'm interested in and document my projects. -->\n<h2>How it works</h2>\n<p>This site was built with <b>NextJS</b>, a React framework that lets you do <i>cool</i> and <i>complicated</i> things with ease, like static HTML generation and server-side rendering.</p>\n<h3>Routing</h3>\n<p>I think the best part about NextJS is how routing your pages works.</p>\n<p>This is how my sites laid out:\r\n<img src=\"/projects/portfolio/routing.png\" alt=\"Portfolio Routing\"></p>\n<p>The <code>pages</code> folder holds all the pages - where each subfolder defines a new page.</p>\n<p>For example, <code>brentchampion.com/projects</code> renders the component <code>pages/projects/index.tsx</code>.</p>\n<p>Dynamic routing works the same way.</p>\n<p>For example, <a>brentchampion.com/projects/portfolio</a> would render <code>pages/projects/[id].tsx</code>, where [id] = portfolio, and all the data is pre-fetched as static props. This means that even though the page routing is <b>dynamic</b>, each page is still built statically at build time.</p>\n<p>This file organization is nice, but these features really shine at build time. When you run <code>npm run build</code>, NextJS is able to pre-render <em>almost</em> everything into static HTML pages.</p>\n<p>This is what the build looks like:\r\n<img src=\"/projects/portfolio/build.png\" alt=\"Build\"></p>\n<h3>Tagging</h3>\n<p>I got really caught up on the idea of a tagging engine. I've seen a few examples I liked while browsing around, but I wanted to build it from scratch. It adds a whole new way to navigate around the site which I think is pretty neat.</p>\n<p>The implementation was simple. Each markdown file has some metadata, including an array of <code>tags</code>. When the <code>ListItem</code> and <code>Post</code> components render, they create hyperlinks on each tag to the url <code>/tags/&#x3C;tag_name></code>.</p>\n<p>It gets tricky with the dynamic routing. I wanted to maintain the static page generation for the base <code>/tags</code> page, but have the same <em>look</em> when hitting a specific tag route.</p>\n<p>For example, if you click <em>react</em> from <code>/tags</code>, it will look identical to the page <code>/tags/react</code>.</p>\n<p>I did this by including an optional <code>tagged</code> prop on the base tag page, and funnelling my dynamic routing through it. By default, the <code>tagged</code> prop is empty, but if a dynamic route is hit, it would look like <code>tagged={[...tags]}</code>. By using the <code>useEffect</code> Hook, I was able to mount this component to the DOM identically to how the base page would interact. Then, by manipulating <code>window.location</code> directly, I was able to change the URL without refreshing the page. Not only does this enforce the idea of <i>reusable components</i>, it also reduced the amount of statically generated pages by a factor of <strong>n!</strong>, where n is the total number of tags.</p>\n<h3>Components</h3>\n<p>All my React components are defined in the <code>components</code> folder. If you're familiar with React, there's nothing too fancy going on here. I make use of hooks where appropriate, as well as tying in some of the features of Next such as the <code>Link</code> and <code>Image</code> components. The only difference between this and a <strong>pure</strong> react project is the use of <code>getStaticProps</code>, which I use to let the compiler know where to do static page generation.</p>\n<p>I absracted my components away from the pages too, so each page basically wraps it's needed components and injects data accordingly. I wanted to be careful with my components since a lot of data was flowing around, so I wrote them in TypeScript.</p>\n<h3>Styling</h3>\n<p>Each component group has a corresponding css module, which defines the styling for the component. Next tries to perform code-splitting, which means only loading exactly whats needed to show the page.</p>\n<p>We can make it for next by easier using <code>.module.css</code> files over normal <code>.css</code> files; reducing the scope of the css to their components. What's more is that NextJS gives unique classes to the css modules. If I define a styling for all <code>h3</code> tags in one module, that styling won't overlap into another component module.</p>\n<p>Unlike my last 2 websites, all of the styling on this website was done by me! To be honest, styling took about twice as long as building the entire architecture/routing powering this website.</p>\n<h3>Deployment</h3>\n<p>The last thing I wanted to set up was an automated deployment pipeline. I decided to use Vercel, a GitHub Actions extension that triggers deployments on pushes and pull requests. I have a couple of unit tests that also run through GitHub Actions to make sure I'm not accidentally pushing broken code.</p>\n<p>All that was left was tying my domain to vercel using an A record, and hitting <code>git push -u origin master</code>.</p>\n","title":"Portfolio","startDate":"2020-11-01","endDate":"2020-11-11","tags":["react","nextjs","typescript","webapp"],"type":"projects","subtitle":"My personal and portfolio website","github":"https://github.com/bchampp/portfolio","demo":"https://brentchampion.com","exists":true}},"__N_SSG":true}