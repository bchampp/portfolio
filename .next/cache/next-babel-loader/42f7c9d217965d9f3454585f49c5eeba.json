{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport fs from 'fs';\nimport path from 'path';\nimport matter from 'gray-matter';\nimport remark from 'remark';\nimport html from 'remark-html';\nexport default class Content {\n  constructor(type) {\n    _defineProperty(this, \"dir\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"files\", void 0);\n\n    this.dir = path.join(process.cwd() + '/content', type);\n    this.files = fs.readdirSync(this.dir);\n  }\n\n  getAllData() {\n    const files = fs.readdirSync(this.dir);\n    let rawData = files.map(name => {\n      const id = name.replace(/\\.md$/, '');\n      const filePath = path.join(this.dir, name);\n      const fileContents = fs.readFileSync(filePath, 'utf8');\n      const result = matter(fileContents);\n      return _objectSpread({\n        id\n      }, result.data);\n    });\n    this.data = this.sort(rawData);\n    return this.data;\n  }\n\n  getAllTags() {\n    let tags = [];\n    this.files.forEach(name => {\n      const id = name.replace(/\\.md$/, '');\n      const fullPath = path.join(this.dir, name);\n      const fileContents = fs.readFileSync(fullPath, 'utf8');\n      const matterResult = matter(fileContents);\n      let exists = false;\n\n      if (matterResult.data.tags) {\n        matterResult.data.tags.forEach(name => {\n          for (var i = 0; i < tags.length; i++) {\n            if (tags[i].name == name) {\n              tags[i].count += 1;\n              exists = true;\n            }\n          }\n\n          if (!exists) {\n            tags.push({\n              name,\n              count: 1\n            });\n          }\n        });\n      }\n    });\n    return tags;\n  }\n\n  getAllIds() {\n    return this.files.map(name => {\n      return {\n        params: {\n          id: name.replace(/\\.md$/, '').toString()\n        }\n      };\n    });\n  }\n\n  async getData(id) {\n    const filePath = path.join(this.dir, `${id}.md`);\n    const fileContents = fs.readFileSync(filePath, 'utf8');\n    const matterResult = matter(fileContents);\n    const processedContent = await remark().use(html).process(matterResult.content);\n    const contentHtml = processedContent.toString();\n    return _objectSpread({\n      id,\n      contentHtml\n    }, matterResult.data);\n  }\n\n  sort(data) {\n    return data;\n  }\n\n}\n\nfunction removeDuplicates(array) {\n  var a = array.concat();\n\n  for (var i = 0; i < a.length; ++i) {\n    for (var j = i + 1; j < a.length; ++j) {\n      if (a[i].name === a[j].name) a.splice(j--, 1);\n    }\n  }\n\n  return a.sort((a, b) => a.count > b.count);\n  ;\n}\n\nexport function getAllTags() {\n  let tags = [];\n  const workTags = new Content('work').getAllTags() || [];\n  const projectTags = new Content('projects').getAllTags() || [];\n  const postTags = new Content('posts').getAllTags() || [];\n  return removeDuplicates(tags.concat(workTags, projectTags, postTags));\n}\nexport function getAllTagIds() {\n  const raw_tags = getAllTags(); // [{name: 'c++', count: 5}, {}...etc.]\n\n  let tagNames = [];\n  raw_tags.forEach(tag => {\n    tagNames.push(tag.name);\n  });\n  let tags = tagNames.map(tag => {\n    return {\n      params: {\n        id: tag\n      }\n    };\n  });\n  return tags;\n}","map":{"version":3,"sources":["C:/Users/Brent Champion/Documents/Coding/portfolio/lib/content.tsx"],"names":["fs","path","matter","remark","html","Content","constructor","type","dir","join","process","cwd","files","readdirSync","getAllData","rawData","map","name","id","replace","filePath","fileContents","readFileSync","result","data","sort","getAllTags","tags","forEach","fullPath","matterResult","exists","i","length","count","push","getAllIds","params","toString","getData","processedContent","use","content","contentHtml","removeDuplicates","array","a","concat","j","splice","b","workTags","projectTags","postTags","getAllTagIds","raw_tags","tagNames","tag"],"mappings":"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","sourcesContent":["import fs from 'fs';\r\nimport path from 'path';\r\nimport matter from 'gray-matter';\r\nimport remark from 'remark';\r\nimport html from 'remark-html';\r\n\r\ninterface Post {\r\n    id: string,\r\n}\r\n\r\ninterface Tag {\r\n    name: string,\r\n    count: number,\r\n}\r\n\r\nexport default class Content {\r\n    dir: string;\r\n    data: Array<Post>;\r\n    files: Array<string>;\r\n\r\n    constructor(type: string) {\r\n        this.dir = path.join(process.cwd() + '/content', type);\r\n        this.files = fs.readdirSync(this.dir);\r\n    }\r\n\r\n    getAllData(): Array<Post> {\r\n        const files = fs.readdirSync(this.dir);\r\n        let rawData = files.map((name): any => {\r\n            const id = name.replace(/\\.md$/, '');\r\n            const filePath = path.join(this.dir, name);\r\n            const fileContents = fs.readFileSync(filePath, 'utf8');\r\n\r\n            const result = matter(fileContents);\r\n\r\n            return {\r\n                id,\r\n                ...result.data,\r\n            };\r\n        });\r\n\r\n        this.data = this.sort(rawData);\r\n        return this.data;\r\n    }\r\n\r\n    getAllTags(): Array<any> {\r\n        let tags: Array<any> = [];\r\n\r\n        this.files.forEach(name => {\r\n            const id = name.replace(/\\.md$/, '');\r\n            const fullPath = path.join(this.dir, name);\r\n            const fileContents = fs.readFileSync(fullPath, 'utf8');\r\n\r\n            const matterResult = matter(fileContents);\r\n\r\n            let exists = false;\r\n            if (matterResult.data.tags) {\r\n                matterResult.data.tags.forEach(name => {\r\n                    for (var i = 0; i < tags.length; i++) {\r\n                        if (tags[i].name == name) {\r\n                            tags[i].count += 1;\r\n                            exists = true;\r\n                        }\r\n                    }\r\n                    if (!exists) {\r\n                        tags.push({\r\n                            name,\r\n                            count: 1\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        })\r\n\r\n        return tags;\r\n    }\r\n\r\n    getAllIds(): Array<any> {\r\n        return this.files.map(name => {\r\n            return {\r\n                params: {\r\n                    id: name.replace(/\\.md$/, '').toString()\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    async getData(id: string) {\r\n        const filePath = path.join(this.dir, `${id}.md`)\r\n        const fileContents = fs.readFileSync(filePath, 'utf8');\r\n        const matterResult = matter(fileContents);\r\n    \r\n        const processedContent = await remark().use(html).process(matterResult.content);\r\n        const contentHtml = processedContent.toString();\r\n    \r\n        return {\r\n            id,\r\n            contentHtml,\r\n            ...matterResult.data\r\n        };\r\n    }\r\n\r\n    sort(data: Array<any>): Array<any> {\r\n        return data;\r\n    }\r\n}\r\n\r\nfunction removeDuplicates(array: Array<any>): Array<any> {\r\n    var a = array.concat();\r\n    for(var i=0; i<a.length; ++i) {\r\n        for(var j=i+1; j<a.length; ++j) {\r\n            if(a[i].name === a[j].name)\r\n                a.splice(j--, 1);\r\n        }\r\n    }\r\n\r\n    return a.sort((a, b) => a.count > b.count);;\r\n}\r\n\r\nexport function getAllTags(): Array<string> {\r\n    let tags: Array<string> = [];\r\n    const workTags = new Content('work').getAllTags() || [];\r\n    const projectTags = new Content('projects').getAllTags() || [];\r\n    const postTags = new Content('posts').getAllTags() || [];\r\n    return removeDuplicates(tags.concat(workTags, projectTags, postTags))\r\n}\r\n\r\nexport function getAllTagIds(){\r\n    const raw_tags = getAllTags(); // [{name: 'c++', count: 5}, {}...etc.]\r\n    \r\n    let tagNames = [];\r\n    raw_tags.forEach(tag => {\r\n        tagNames.push(tag.name);\r\n    })\r\n\r\n    let tags = tagNames.map(tag => {\r\n        return {\r\n            params: {\r\n                id: tag\r\n            }\r\n        }\r\n    })\r\n    return tags;\r\n}"]},"metadata":{},"sourceType":"module"}