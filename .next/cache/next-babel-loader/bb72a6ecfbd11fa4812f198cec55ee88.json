{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport fs from 'fs';\nimport path from 'path';\nimport matter from 'gray-matter';\nimport remark from 'remark';\nimport html from 'remark-html';\nexport default class Content {\n  constructor(type) {\n    _defineProperty(this, \"dir\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"files\", void 0);\n\n    this.dir = path.join(process.cwd() + '/content', type);\n    this.files = fs.readdirSync(this.dir);\n  }\n\n  getAllData() {\n    const files = fs.readdirSync(this.dir);\n    let rawData = files.map(name => {\n      const id = name.replace(/\\.md$/, '');\n      const filePath = path.join(this.dir, name);\n      const fileContents = fs.readFileSync(filePath, 'utf8');\n      const result = matter(fileContents);\n      return _objectSpread({\n        id\n      }, result.data);\n    });\n    this.data = this.sort(rawData);\n    return this.data;\n  }\n\n  getAllTags() {\n    let tags = [];\n    this.files.forEach(name => {\n      const id = name.replace(/\\.md$/, '');\n      const fullPath = path.join(this.dir, name);\n      const fileContents = fs.readFileSync(fullPath, 'utf8');\n      const matterResult = matter(fileContents);\n      let exists = false;\n\n      if (matterResult.data.tags) {\n        matterResult.data.tags.forEach(name => {\n          for (var i = 0; i < tags.length; i++) {\n            if (tags[i].name == name) {\n              tags[i].count += 1;\n              exists = true;\n            }\n          }\n\n          if (!exists) {\n            tags.push({\n              name,\n              count: 1\n            });\n          }\n        });\n      }\n    });\n    return tags;\n  }\n\n  getAllIds() {\n    return this.files.map(name => {\n      return {\n        params: {\n          id: name.replace(/\\.md$/, '').toString()\n        }\n      };\n    });\n  }\n\n  async getData(id) {\n    const filePath = path.join(this.dir, `${id}.md`);\n    const fileContents = fs.readFileSync(filePath, 'utf8');\n    const matterResult = matter(fileContents);\n    const processedContent = await remark().use(html).process(matterResult.content);\n    const contentHtml = processedContent.toString();\n    return _objectSpread({\n      id,\n      contentHtml\n    }, matterResult.data);\n  }\n\n  sort(data) {\n    return data;\n  }\n\n}\n\nfunction removeDuplicates(array) {\n  var a = array.concat();\n\n  for (var i = 0; i < a.length; ++i) {\n    for (var j = i + 1; j < a.length; ++j) {\n      if (a[i] === a[j]) a.splice(j--, 1);\n    }\n  }\n\n  return a;\n}\n\nexport function getAllTags() {\n  let tags = [];\n  const workTags = new Content('work').getAllTags() || [];\n  const projectTags = new Content('projects').getAllTags() || [];\n  const postTags = new Content('posts').getAllTags() || [];\n  return removeDuplicates(tags.concat(workTags, projectTags, postTags));\n}","map":null,"metadata":{},"sourceType":"module"}